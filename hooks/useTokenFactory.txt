// FILE: hooks/useTokenFactory.ts

import { useState, useRef, useEffect } from "react";
import { useWallet, useConnection } from "@solana/wallet-adapter-react"; // Added useConnection
import { useProgram } from "@/components/solana-provider";
import * as anchor from "@coral-xyz/anchor";
import {
  PublicKey,
  SystemProgram,
  Keypair,
  SYSVAR_RENT_PUBKEY,
  SYSVAR_INSTRUCTIONS_PUBKEY,
} from "@solana/web3.js";
import {
  ASSOCIATED_TOKEN_PROGRAM_ID,
  getAssociatedTokenAddressSync,
  TOKEN_2022_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
} from "@solana/spl-token";
import { MPL_TOKEN_METADATA_PROGRAM_ID } from "@metaplex-foundation/mpl-token-metadata";
import { Token } from "@/types/token";

export type TokenStandard = "token" | "token-2022";
export type AddressMethod = "random" | "custom"; // New type

export const useTokenFactory = (onTokenCreated: (token: Token) => void) => {
  const { publicKey } = useWallet();
  const { connection } = useConnection(); // Needed for account verification
  const { program } = useProgram();

  // --- WIZARD STATE ---
  const [step, setStep] = useState(1);
  const [addressMethod, setAddressMethod] = useState<AddressMethod>("random");

  // --- TOKEN CONFIG STATE ---
  const [tokenStandard, setTokenStandard] =
    useState<TokenStandard>("token-2022");

  // Custom Address State
  const [uploadedKeypair, setUploadedKeypair] = useState<Keypair | null>(null);
  const [keypairFileError, setKeypairFileError] = useState<string | null>(null);

  // Form Data (Expanded)
  const [formData, setFormData] = useState({
    name: "",
    symbol: "",
    decimals: "9",
    initialSupply: "",
    description: "", // New
    website: "", // New
    twitter: "", // New
    telegram: "", // New
    transferFee: "0",
    interestRate: "0",
    nonTransferable: false,
    enablePermanentDelegate: false,
    defaultAccountStateFrozen: false,
    revokeUpdateAuthority: false,
    isMintable: true,
  });

  // Vanity Grinder State
  const [vanityPrefix, setVanityPrefix] = useState("");
  const [vanityResults, setVanityResults] = useState<Keypair[]>([]);
  const [selectedVanityKey, setSelectedVanityKey] = useState<string | null>(
    null
  );
  const [isGrinding, setIsGrinding] = useState(false);
  const [stats, setStats] = useState({ scanned: 0, speed: 0 });
  const grindingRef = useRef(false);

  // Image State
  const [tokenImage, setTokenImage] = useState<File | null>(null);
  const [tokenImagePreview, setTokenImagePreview] = useState<string | null>(
    null
  );

  // Transaction State
  const [isCreating, setIsCreating] = useState(false);
  const [statusMessage, setStatusMessage] = useState("");
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [signature, setSignature] = useState<string | null>(null);

  // --- HELPERS ---

  // 1. JSON Keypair Upload Handler
  const handleKeypairUpload = async (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setKeypairFileError(null);
    setUploadedKeypair(null);

    const reader = new FileReader();
    reader.onload = async (event) => {
      try {
        const content = event.target?.result as string;
        const parsed = JSON.parse(content);

        // Basic validation: must be array of numbers (standard Solana format)
        if (!Array.isArray(parsed) || parsed.length !== 64) {
          setKeypairFileError(
            "Invalid JSON format. Must be a [64 byte] array."
          );
          return;
        }

        const kp = Keypair.fromSecretKey(new Uint8Array(parsed));

        // SECURITY: Check if account already exists/used
        const accountInfo = await connection.getAccountInfo(kp.publicKey);
        if (accountInfo) {
          setKeypairFileError(
            `Address ${kp.publicKey
              .toBase58()
              .slice(0, 6)}... is already active on chain. Use a fresh keypair.`
          );
          return;
        }

        setUploadedKeypair(kp);
        // If they were using vanity, clear it to avoid confusion
        setSelectedVanityKey(null);
        setVanityResults([]);
      } catch (err) {
        setKeypairFileError("Failed to parse JSON file.");
      }
    };
    reader.readAsText(file);
  };

  // 2. Vanity Logic (Same as before)
  const stopGrinding = () => {
    grindingRef.current = false;
    setIsGrinding(false);
  };

  const grindVanityAddress = (continueSearch = false) => {
    if (!vanityPrefix) return;
    // ... (Keep existing vanity logic logic here) ...
    const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
    if (!base58Regex.test(vanityPrefix)) {
      setErrors({ vanity: "Invalid characters. No 0, O, I, l." });
      return;
    }
    grindingRef.current = true;
    setIsGrinding(true);
    if (!continueSearch) {
      setVanityResults([]);
      setSelectedVanityKey(null);
      setStats({ scanned: 0, speed: 0 });
    }
    setErrors((prev) => ({ ...prev, vanity: "" }));
    let count = 0;
    let lastUpdate = Date.now();
    let startTime = Date.now();
    const findMatch = () => {
      if (!grindingRef.current) return;
      const burstStart = Date.now();
      while (Date.now() - burstStart < 20) {
        const kp = Keypair.generate();
        count++;
        if (kp.publicKey.toBase58().startsWith(vanityPrefix)) {
          setVanityResults((prev) => [...prev, kp]);
        }
      }
      if (Date.now() - lastUpdate > 500) {
        const elapsed = (Date.now() - startTime) / 1000;
        setStats({ scanned: count, speed: Math.round(count / elapsed) });
        lastUpdate = Date.now();
      }
      if (count > 500000) {
        stopGrinding();
        return;
      }
      requestAnimationFrame(findMatch);
    };
    findMatch();
  };

  // 3. Form Handlers
  const handleInputChange = (field: string, value: any) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const handleImageSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setTokenImage(file);
      setTokenImagePreview(URL.createObjectURL(file));
      setErrors((prev) => ({ ...prev, tokenImage: "" }));
    }
  };

  const uploadToIpfs = async (
    file: File | Blob,
    isJson = false
  ): Promise<string> => {
    const data = new FormData();
    data.append("file", file, isJson ? "metadata.json" : undefined);
    const res = await fetch("/api/upload", { method: "POST", body: data });
    if (!res.ok) throw new Error("Upload failed");
    return (await res.json()).url;
  };

  const validate = () => {
    const errs: Record<string, string> = {};
    if (!formData.name.trim()) errs.name = "Name required.";
    if (!formData.symbol.trim()) errs.symbol = "Symbol required.";
    if (!tokenImage) errs.tokenImage = "Image required.";
    if (Number(formData.decimals) < 0 || Number(formData.decimals) > 18)
      errs.decimals = "Invalid decimals.";
    if (Number(formData.initialSupply) <= 0)
      errs.initialSupply = "Invalid supply.";

    // Validate Step 1 Check
    if (addressMethod === "custom" && !uploadedKeypair && !selectedVanityKey) {
      errs.address = "You selected Custom Address but haven't provided one.";
    }

    setErrors(errs);
    return Object.keys(errs).length === 0;
  };

  // --- CREATE TOKEN ---
  const createToken = async () => {
    if (!validate() || !publicKey || !program) return;

    setIsCreating(true);
    setSignature(null);
    setErrors({});

    try {
      setStatusMessage("Uploading Image to IPFS...");
      const imgUrl = await uploadToIpfs(tokenImage!);

      setStatusMessage("Uploading Metadata...");

      // Construct rich metadata
      const metadataPayload = {
        name: formData.name,
        symbol: formData.symbol,
        description: formData.description, // Optional Description
        image: imgUrl,
        external_url: formData.website, // Optional Website
        attributes: [] as any[],
      };

      if (formData.twitter)
        metadataPayload.attributes.push({
          trait_type: "Twitter",
          value: formData.twitter,
        });
      if (formData.telegram)
        metadataPayload.attributes.push({
          trait_type: "Telegram",
          value: formData.telegram,
        });

      const metaUrl = await uploadToIpfs(
        new Blob([JSON.stringify(metadataPayload)], {
          type: "application/json",
        }),
        true
      );

      setStatusMessage("Building Transaction...");

      // DETERMINING THE MINT KEYPAIR
      let mintKeypair: Keypair;

      if (addressMethod === "custom") {
        if (uploadedKeypair) {
          mintKeypair = uploadedKeypair;
        } else if (selectedVanityKey) {
          const found = vanityResults.find(
            (k) => k.publicKey.toBase58() === selectedVanityKey
          );
          if (found) mintKeypair = found;
          else mintKeypair = Keypair.generate(); // Fallback (shouldn't happen due to validate)
        } else {
          mintKeypair = Keypair.generate();
        }
      } else {
        mintKeypair = Keypair.generate(); // Random (Fast)
      }

      const decimals = Number(formData.decimals);
      const supply = new anchor.BN(formData.initialSupply).mul(
        new anchor.BN(10).pow(new anchor.BN(decimals))
      );
      const progId =
        tokenStandard === "token-2022"
          ? TOKEN_2022_PROGRAM_ID
          : TOKEN_PROGRAM_ID;
      const metaProgId = new PublicKey(
        MPL_TOKEN_METADATA_PROGRAM_ID.toString()
      );

      const [userPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("user"), publicKey.toBuffer()],
        program.programId
      );
      const [metaPda] = PublicKey.findProgramAddressSync(
        [
          Buffer.from("metadata"),
          metaProgId.toBuffer(),
          mintKeypair.publicKey.toBuffer(),
        ],
        metaProgId
      );
      const tokenAccount = getAssociatedTokenAddressSync(
        mintKeypair.publicKey,
        publicKey,
        false,
        progId
      );

      const fees = formData.transferFee
        ? Math.floor(Number(formData.transferFee) * 100)
        : 0;
      const interest = formData.interestRate
        ? Math.floor(Number(formData.interestRate))
        : 0;

      setStatusMessage("Please sign transaction...");

      const tx = await program.methods
        .createToken(
          formData.name,
          formData.symbol,
          metaUrl,
          decimals,
          supply,
          tokenStandard === "token-2022"
            ? { fungible2022: {} }
            : ({ fungible: {} } as any),
          fees,
          interest,
          formData.nonTransferable,
          formData.enablePermanentDelegate,
          formData.defaultAccountStateFrozen,
          formData.revokeUpdateAuthority,
          !formData.isMintable
        )
        .accountsPartial({
          userAccount: userPda,
          authority: publicKey,
          mint: mintKeypair.publicKey,
          tokenAccount,
          metadata: metaPda,
          tokenMetadataProgram: metaProgId,
          systemProgram: SystemProgram.programId,
          tokenProgram: progId,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
          rent: SYSVAR_RENT_PUBKEY,
          instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
        })
        .signers([mintKeypair])
        .rpc();

      setSignature(tx);
      setStatusMessage("Success!");

      onTokenCreated({
        id: mintKeypair.publicKey.toBase58(),
        mintAddress: mintKeypair.publicKey.toBase58(),
        name: formData.name,
        symbol: formData.symbol,
        decimals,
        supply: Number(formData.initialSupply),
        balance: Number(formData.initialSupply),
        createdAt: new Date().toISOString(),
        status: "active",
        image: imgUrl,
        isMintable: formData.isMintable,
        programId: progId.toBase58(),
        authority: publicKey.toBase58(),
      });
    } catch (e: any) {
      console.error(e);
      setErrors({ form: e.message || "Transaction failed. Please try again." });
    } finally {
      setIsCreating(false);
      // SECURITY: Clear the private key from memory immediately
      setUploadedKeypair(null);
    }
  };

  return {
    // Wizard State
    step,
    setStep,
    addressMethod,
    setAddressMethod,

    // Core Data
    formData,
    handleInputChange,
    tokenStandard,
    setTokenStandard,

    // Custom Address - Upload
    handleKeypairUpload,
    uploadedKeypair,
    keypairFileError,
    setUploadedKeypair,

    // Custom Address - Vanity
    vanityPrefix,
    setVanityPrefix,
    vanityResults,
    isGrinding,
    grindVanityAddress,
    stopGrinding,
    stats,
    selectedVanityKey,
    setSelectedVanityKey,

    // Image
    tokenImage,
    tokenImagePreview,
    handleImageSelect,

    // Status
    isCreating,
    statusMessage,
    errors,
    setErrors,
    signature,
    createToken,
  };
};
